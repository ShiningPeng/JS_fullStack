# ques1  javascript全局执行上下文，为我们创建了两个东西：全局对象和this关键字
# __proto__和prototype
  万物都有proto，只有function才有prototype
  只有函数才有原型链,对象没有
  对象要看到原型直接.__proto__，就可以看到
  而函数要看到原型，需要.__proto__得到是用方法包起来的，就像是女孩子化了妆，再.__proto__之后才能看到素颜，也就是原型。

# new方法的执行原理
  1. 创建一个空对象，构造函数的this指向这个空对象
  2. 这个新对象被执行[原型]连接 
  3. 执行构造函数，将构造函数的属性或方法添加到this引用的对象上
  4. 如果构造函数中没有返回其他对象，那么返回this,即创建的新对象。否则，返回构造函数返回的对象

#ques2  call,bind,apply
  1. b.call(a) 相当于把b里面的作用域强行指向到a里面去，此时b就可以调用a里面的fn
  .call方法第一个参数是要this作用域指向的地方，后面的参数都是该作用域里要用到的值
  2. b.apply(a) 与 .call方法 用法一致，不一样的是，除第一个参数外的参数都要放到一个数组里，b.apply(a,[9,2])
  3. b.call() || b.apply() 此时this的作用域会指向window
  4. var c = b.bind(a);
     c();
     bind方法返回的是一个修改后的新的函数，所以该用函数该有的姿态去调用
     bind方法接收的参数是按照形参的顺序进行的

#ques3 浅拷贝和深拷贝
  1. 数组解构：
    let [x, y, z] = [1, 2, 3]
    //x=1,y=2,z=3
  2. 对象解构：
    let {foo, bar} = {foo:'aaa', bar:'bbb'}
    //foo='aaa',bar:'bbb'
    //另：允许给赋值的变量重命名 
      let {foo: baz} = {foo:'aaa'}
      //baz='aaa'
  3. 浅拷贝只是第一层属性进行拷贝，当第一层的属性为基本数据类型时，新对象和原对象互不影响，当第一层的属性为# 复杂数据类型 # 时，那么新对象和原对象的属性值其指向的是同一块内存地址(是同步更新的)
     深拷贝是将对象及值复制过来，两个对象修改其中任意一个的值，另一个的值不会改变

#ques4 闭包
  1. 什么是闭包？闭包是指有权限访问另一个函数作用域中的变量的函数
  2. 闭包的作用：(1)能够访问函数定义时所在的词法作用域(阻止其被回收)
                (2)私有化变量
                (3)模拟块级作用域
  所以尽量少使用闭包，不然会导致内存泄漏，项目，浏览器卡顿，进程等
